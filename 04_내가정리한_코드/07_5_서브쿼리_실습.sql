/************************************************
         서브쿼리 실습 - 가장 높은 SAL을 받는 직원 정보
 *************************************************/

-- 가장 높은 SAL을 받는 직원정보
SELECT * FROM HR.EMP WHERE SAL = (SELECT MAX(SAL) FROM HR.EMP);

-- 조인
SELECT A.*
FROM HR.EMP A
	JOIN (SELECT MAX(SAL) SAL FROM HR.EMP) B
ON A.SAL = B.SAL;

-- ANALYTIC SQL
SELECT * FROM
(
SELECT *,
	ROW_NUMBER() OVER (ORDER BY SAL DESC) AS RNUM
FROM HR.EMP
) A WHERE RNUM = 1;


/************************************************
     서브쿼리 실습 - 부서별로 가장 높은 SAL을 받는 직원 정보
 *************************************************/
-- 부서별로 가장 높은 SAL을 받는 직원 상세 정보. 비상관 서브쿼리
SELECT * FROM HR.EMP WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) AS SAL FROM HR.EMP GROUP BY DEPTNO) ORDER BY EMPNO;

-- 상관서브쿼리
SELECT * FROM HR.EMP A
WHERE SAL = (SELECT MAX(SAL) AS SAL FROM HR.EMP X
             WHERE X.DEPTNO = A.DEPTNO);

-- ANALYTIC SQL
SELECT * FROM
(
SELECT *,
	ROW_NUMBER() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS RNUM
FROM HR.EMP
) A WHERE RNUM = 1
ORDER BY EMPNO;


/************************************************
     서브쿼리 실습 - 직원의 가장 최근 부서 근무이력 조회
 *************************************************/

DROP TABLE IF EXISTS HR.EMP_DEPT_HIST_01;

-- TODATE가 99991231가 아닌 경우를 한개 레코드로 생성하기 위해 임시 테이블 생성
CREATE TABLE HR.EMP_DEPT_HIST_01
AS
SELECT * FROM HR.EMP_DEPT_HIST;


UPDATE HR.EMP_DEPT_HIST_01
SET TODATE=TO_DATE('1983-12-24', 'YYYY-MM-DD')
WHERE EMPNO = 7934 AND TODATE=TO_DATE('99991231', 'YYYYMMDD');

SELECT * FROM HR.EMP_DEPT_HIST_01;

-- 직원의 가장 최근 부서 근무이력 조회. 비상관 서브쿼리
SELECT * FROM HR.EMP_DEPT_HIST_01 A WHERE (EMPNO, TODATE) IN (SELECT EMPNO, MAX(TODATE) FROM HR.EMP_DEPT_HIST_01 X
GROUP BY EMPNO);

-- 상관 서브쿼리
SELECT * FROM HR.EMP_DEPT_HIST_01 A WHERE TODATE = (SELECT MAX(TODATE) FROM HR.EMP_DEPT_HIST_01 X WHERE X.EMPNO=A.EMPNO);

-- ANALYTIC SQL
SELECT *
FROM (
SELECT *
	, ROW_NUMBER() OVER (PARTITION BY EMPNO ORDER BY TODATE DESC) AS RNUM
FROM HR.EMP_DEPT_HIST_01
)A WHERE RNUM = 1;


/************************************************
 서브쿼리 실습 - 고객의 첫번째 주문일의 주문정보와 고객 정보를 함께 추출
 *************************************************/

-- 고객의 첫번째 주문일의 ORDER_ID, ORDER_DATE, SHIPPED_DATE와 함께 고객명(CONTACT_NAME), 고객거주도시(CITY) 정보를 함께 추출
SELECT A.ORDER_ID, A.ORDER_DATE, A.SHIPPED_DATE, B.CONTACT_NAME, B.CITY
FROM NW.ORDERS A
	JOIN NW.CUSTOMERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID
WHERE A.ORDER_DATE = (SELECT MIN(ORDER_DATE) FROM NW.ORDERS X WHERE X.CUSTOMER_ID = A.CUSTOMER_ID);

-- ANALYTIC SQL
SELECT ORDER_ID, ORDER_DATE, SHIPPED_DATE, CONTACT_NAME, CITY
FROM
(
SELECT A.ORDER_ID, A.ORDER_DATE, A.SHIPPED_DATE, B.CONTACT_NAME, B.CITY,
	ROW_NUMBER() OVER (PARTITION BY A.CUSTOMER_ID ORDER BY A.ORDER_DATE) AS RNUM
FROM NW.ORDERS A
	JOIN NW.CUSTOMERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID
)A WHERE RNUM = 1;



/************************************************
 서브쿼리 실습 - 고객별 주문 상품 평균 금액보다 더 큰 금액의 주문 상품명, 주문번호, 주문 상품금액을 구하되 고객명과 고객도시명을 함께 추출
 *************************************************/

-- 고객별 주문상품 평균 금액
SELECT A.CUSTOMER_ID, AVG(B.AMOUNT) AVG_AMOUNT FROM NW.ORDERS A
JOIN NW.ORDER_ITEMS B
ON A.ORDER_ID = B.ORDER_ID
GROUP BY CUSTOMER_ID;

-- 상관 서브쿼리로 구하기
SELECT A.CUSTOMER_ID, A.CONTACT_NAME, A.CITY, B.ORDER_ID, C.PRODUCT_ID, C.AMOUNT, D.PRODUCT_NAME
FROM NW.CUSTOMERS A
	JOIN NW.ORDERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID
	JOIN NW.ORDER_ITEMS C ON B.ORDER_ID = C.ORDER_ID
	JOIN NW.PRODUCTS D ON C.PRODUCT_ID = D.PRODUCT_ID
WHERE C.AMOUNT >= (SELECT AVG(Y.AMOUNT) AVG_AMOUNT
					FROM NW.ORDERS X
						JOIN NW.ORDER_ITEMS Y ON X.ORDER_ID = Y.ORDER_ID
					WHERE X.CUSTOMER_ID =A.CUSTOMER_ID
					GROUP BY X.CUSTOMER_ID
					)
ORDER BY A.CUSTOMER_ID, AMOUNT;

-- ANALYTIC SQL로 구하기
SELECT CUSTOMER_ID, CONTACT_NAME, CITY, ORDER_ID, PRODUCT_ID, AMOUNT, PRODUCT_NAME
FROM (
	SELECT A.CUSTOMER_ID, A.CONTACT_NAME, A.CITY, B.ORDER_ID, C.PRODUCT_ID, C.AMOUNT, D.PRODUCT_NAME
	, AVG(AMOUNT) OVER (PARTITION BY A.CUSTOMER_ID ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS AVG_AMOUNT
	FROM NW.CUSTOMERS A
		JOIN NW.ORDERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID
		JOIN NW.ORDER_ITEMS C ON B.ORDER_ID = C.ORDER_ID
		JOIN NW.PRODUCTS D ON C.PRODUCT_ID = D.PRODUCT_ID
) A
WHERE A.AMOUNT >= A.AVG_AMOUNT
ORDER BY CUSTOMER_ID, AMOUNT;